The first practical textbook on AnyLogic 7 from AnyLogic developers. AnyLogic is the unique simulation software tool that supports three simulation modeling methods: system dynamics, discrete event, and agent based modeling and allows you to create multi-method models. The book is structured around four examples: a model of a consumer market, an epidemic model, a model of a small job shop, and an airport model. We also give some theory on different modeling methods. You can consider this book as your first guide in studying AnyLogic 7. Having read this book and completed the exercises, you will be able to create discrete-event and pedestrian models using process flowcharts, to draw stock and flow diagrams, and to build simple agent based models.

Abstract. Nowadays simulation modeling is applied for solving a wide range of problems. There are simulations which require significant performance and time resources. To decrease overall simulation time a model can be converted to a distributed system and executed on a computer network. The goal of this project is to create a library enabling clear and rapid development parallel dis- crete event models in AnyLogic. The library is aimed for professionals in computer simulation and helps to reduce code amount. The project includes a research on different synchronization algorithms. In this paper we present techniques which can be used in creating distributed models. We present com- parison of a single threaded model with a distributed model implementing optimistic algorithm. The comparison shows a significant improvement in wallclock time achieved by separating the model into independent submodels with minimal communications. 
Keywords: AnyLogic, parallel discrete event simulation, Java RMI, agent based simulation, epidemic, Time Warp. 
1 Introduction 
Simulation modeling nowadays is applied for a wide range of problems. Computer simulation modeling can be considered as an imitation of a real life implemented by a computer program. There are many tools for designing and executing simulation models. Some of these tools are aimed for specific application areas, some of them are general purpose simulation tools. Regardless of the tool any execution or simula- tion of a model requires CPU time and consumes memory. At the moment the need for global optimization causes requirements for flexibility, accuracy and level of de- tails of simulation models to grow rapidly. These requirements often hit limitations of modern computers. For such simulations result cannot be obtained in a reasonable amount of time and therefore special techniques should be applied to decrease the wallclock time. One of the approaches is to remove certain details, events or proc- esses from a model so that the wallclock time obviously decreases, but accuracy of output results decreases as well. If decreasing the precision of the result is impossible then distribution of a model execution can be applied. 
If a computer model is distributed over a network, components of the model are executed on independent computers. Theoretically, if the communication between the 
V. Malyshkin (Ed.): PaCT 2009, LNCS 5698, pp. 226–236, 2009. © Springer-Verlag Berlin Heidelberg 2009 
Parallel Discrete Event Simulation with AnyLogic 227 
submodels is negligible then increase in the execution performance is proportional to the number of computers in the network. In case of a data exchange between the model components the communication time should be added to the overall wallclock time. 
Most of simulation tools which are practically used for solving problems are single threaded. Arena, Extend, VenSim are single threaded applications. To create a dis- tributed simulation a modeler has to leave an environment to which he used to and has to recreate the model using environment which supports distributed applications. Recreation of a model may require translation of the system behavior from a model- ing language to a programming language. E.g. a process description with a sequence of library blocks should be translated into Java code. Additional and really significant amount of coding should be made up to carry out support of communications between the distributed components. For professionals in computer simulation these tasks may occur to be out of their scope. 
In this project we are developing techniques for rapid development of distributed simulation models. We are aimed to eliminate coding related steps of the model creat- ing by adding library blocks directly into a simulation modeling tool. Modeler will be focused on a modeling process rather than programming by using these blocks. The modeler would need to logically divide a model into blocks with minimal communi- cations between these blocks. Then by adding several library blocks and making a simplified setup the single threaded model will be easily turned into a distributed model. Then such a model can be executed on the computer network. 
2 Simulation Platform 
Most of simulation tools were originally designed for specific applications: manufactur- ing, material handling, financial simulations, logistics optimization. There are several platforms positioned as a general purpose tools which allow user to create a simulation of almost any real life object. In this project we are developing a solution for wide range of applications and therefore the number one criterion for selecting a simulation tool is that the chosen tool has to be a general purpose tool. 
The second priority criterion is flexibility of a tool. Developing a library for dis- tributed modeling obviously requires ability to create user libraries. Furthermore there should be enough functions and language constructs for programming complex li- brary blocks with network interfaces. In many tools user is limited with a simplified scripting language while developing library blocks. 
At the very initial stage of the project we made a research on the simulation tools using two criteria described earlier (general purpose tool and flexible library devel- opment). As the result of this research we have selected AnyLogic developed by XJ Technologies. AnyLogic is based on Java and is positioned as a general purpose simulation tool. 
After the tool selection we made a review of existing Java technologies helping developing distributed applications. Any distributed application is a set of program components communicating with each other. Any single component is an independent program block, executed in a separate thread. In general when developing a distrib- uted system programmers typically reuse one of existing platforms for messaging or 
228 M. Kondratyev and M. Garifullin 
data exchange over the network. Developing a customized messaging platform from scratch significantly increases a development time, leverages need for testing and later support. Using existing software or predefined components for distributed appli- cations on a base level minimizes risks in this part of the system. 
There are three widely used technologies helping programmers to create distributed applications with Java. Abbreviations are RMI, CORBA and DCOM. In this project we use RMI (figure 1). 
Fig. 1. Java RMI technology 
The main factor influenced on our decision is that RMI is fully integrated with Java from version 1.1. AnyLogic is based on Java and allows a user to fully use power of Java in any place of a model or a library. Current version of AnyLogic uses Java 1.6 and therefore RMI is available in all versions of AnyLogic (educational, regular, older builds). An object which supposed to be accessed remotely is visible to a Java name- space via special interface. This interface should be published in RMI namespace. This interface contains description of methods which can be invoked for the object. A client interacts with the object using a reference to the published interface. Calling remote methods is clear for a programmer and is done in the same way as calling regular Java local functions. The clearness is another advantage of using RMI. RMI also supports data sending from one object to another remote object. Data is serialized using standard Java Serialization mechanisms, and then sent over the network. 
The essential of a distributed simulation is a logic that synchronizes distributed parts of the model. The logic is build on top of the messaging platform and can be considered as a higher level in the overall system. The synchronization logic uses subset of RMI functions to send messages between the model components. 
3 Synchronizing Model Components 
AnyLogic is mostly used for creating discrete event models. In this project we will consider only discrete event simulations. Distributing continues simulations requires extremely specialized techniques and is out of scope of this project. 
AnyLogic is a general purpose simulation tool which supports all of the three well known approaches for building simulation models. AnyLogic supports System Dy- namics which typically deals with continuous systems with equations. Also the tool supports Agent Based and Process-Centric (which is frequently called simply the Dis- crete Event and utilized for queuing systems modeling) approaches used for imitating 
Parallel Discrete Event Simulation with AnyLogic 229 
systems with discrete events. Presented library allows distribute any discrete event model, agent based or process-centric for instance. Since agent based models are the most exigent for computing resources, we considered that the library would almost be used for distributing agent based models. 
The base concept of discrete event simulation is an event. Event is something that occurs in a moment of time, event is an atomic execution of a sequence of commands. While developing any discrete event model we transfer only discrete events into the model from the real world. We assume that nothing changes in between two events. Only events may cause changes in the system, also events may generate or cancel other events. 
A model reflects a real life object with a set of state variables, where each variable corresponds to a property of an object. Set of values of variables characterizes a state of the system in the particular moment in a model time and the list of planned events, which should occur in model time future. In most cases of discrete event modeling the order of concurrent events execution is important. If an execution order differs from an order assumed by a model developer, results of the simulation won’t be correct. Besides, an engine should ensure reproducibility of simulations runs. It means that consequent executions with the same input should produce the same result. 
Event management in AnyLogic is implemented with a single event queue. This queue stores current events, which would occur in the current moment of model time, past or already processed events and future events. AnyLogic engine selects one of events scheduled for a current moment of model time. This event is then executed – a sequence of Java commands associated with this event is executed. This event may create a new event in a future or cancel an event already scheduled. Then the engine selects the next event from the events scheduled for the current moment of model time. 
In case of single threaded models AnyLogic engine manages events to ensure cor- rect sequence of events execution, but in case of parallel (distributed) discrete event simulation we divide a problem into a set of sub problems and each of them is repre- sented with an independent AnyLogic model. Thus each submodel has its own model time and own event queue. One submodel can interact with another submodel by passing messages. As a result of receiving a message a new event will be generated in the submodel. If an event should be generated at time t, whereas the model time has progressed up to t + Δt, difficulties may take place. E.g. a plane arrives from a remote city to a local city on Jan 1st, but the local city time is Jan 10th. This event delay is called “causality problem”. 
To avoid causality problem one have to implement special synchronization algo- rithms. There are two common classes of such algorithms: conservative and optimis- tic algorithms [1, 2, 3]. 
The aim of conservative algorithms is to avoid causality problem. The basic as- sumption of conservative algorithms is that distributed components use FIFO chan- nels for message passing. Thus the submodel receives messages in the same order as the remote submodel sends them. If a submodel at the moment of time t receives a message which was send by a remote submodel at time t + Δt, then there will be no messages in Δt interval coming from that remote submodel. Therefore the receiving submodel can safely continue model execution in the Δt interval assuming that there will be no new events and therefore there will be no causality problems. If there are 
230 M. Kondratyev and M. Garifullin 
no messages coming from remote model then computations should be paused to pre- vent causality problems. Upon receiving a message computations can be resumed. 
The major disadvantage of conservative algorithms is low performance caused by pausing computations while waiting for an incoming message. This significantly de- creases effect of running model parts in parallel. Besides that, a system running under conservative algorithm may run into a deadlock. If there is a cycle of submodels where each submodel waits for a message from each other a deadlock occurs and the whole model execution stops. Deadlock prevention or resolving requires additional logic. 
Optimistic or aggressive algorithms are based on a concept of a rollback. Whereas conservative algorithms prevent system components from a causality problem, opti- mistic algorithms ignore such risk until it actually happens. If a causality problem is detected then optimistic algorithms use some kind of compensation algorithms. Mostly wide used algorithms are periodically saving a model state. If a causality problem occurs then the algorithm performs the model rollback to a historical state. Then a new event is inserted into a model and the model resumes its execution. 
The disadvantage of optimistic algorithms is follows: when a submodel performs a rollback it should cancel all messages sent to other submodels during the rollback period. Cancellation is done via so called antimessages. Each antimessage may cause rollback in other submodels which turns into an escalating number of rollbacks all over the system. Each rollback requires CPU time and therefore a large amount of rollbacks may take greater losses than the total increase in performance caused by distributing. 
There are several techniques that allow decreasing a number of rollbacks. One of the techniques is so called relaxed synchronization. This technique can be applied if order of execution of events is not very important. In this case it is assumed that all events in a certain time window are imminent and therefore an order of execution is not important. Using this technique may violate the requirement of reproducible re- sults, but significantly increases performance of optimistic algorithms. 
Conservative and optimistic algorithms are two mostly used algorithms for syn- chronizing distributed submodels. Depending on a problem each algorithm will give different performance gain. In a distributed system the algorithm is the number one factor which influences the success of turning a single threaded model into a distrib- uted one. 
4 Example of a Distributed Agent Based Model 
In this project we are developing a library that enables a simulation modeler to extend a model with an ability to run on a computer network. The model parts can be syn- chronized using different algorithms therefore allowing a modeler to choose an opti- mal synchronization algorithm. 
The first version of the library is designed to support a subclass of discrete event models. The subclass is called Agent Based modeling and is a type of modeling which is widely used to solve many different problems. There is no common definition of what is agent based and what is agent. People still discuss what properties should a thing have to be called an agent. Commonly referenced features are ability to move, ability to learn, communications etc. From practical point of view we will stress only 
Parallel Discrete Event Simulation with AnyLogic 231 
one feature common for all agent based models. Agents based models are essentially decentralized. There is no such place where a global behavior of a system is defined. On a contrary, a modeler defines a system behavior on a level of individual compo- nents and the global behavior emerges as the result of many individuals sharing the same environment, following their own local rules and communicating with each other. This approach is widely used for describing complex social and economic models. Besides flexibility agent based models typically require much more computa- tional resources than traditional equation based models. There are simulations where accuracy can be achieved only by modeling millions of agents concurrently in the same environment with the same timescale. Therefore we expect that this project will give a lot of benefits and will break certain limits in agent based simulations. 
Up to this moment we have developed as baseline version of the library which is a part of AnyLogic simulation tool. The library uses RMI for passing messages between distributed parts. In the following section an example of creating a distributed model is provided. The example is based on a classical agent based problem of an epidemic. 
Fig. 2. Model of behavior of agents in particular city. On the left there is a statechart represent- ing the behavior of each agent. 
The problem considers a region with cities. People live in cities, communicate with each other and travel between the cities. The assumption is that people or agents leave in metric space and can be Susceptible, then Infectious if infected with another person and than being Recovered. Disease spreading is distance based – only in a certain range infected person may pass a disease to a susceptible person (figure 2). 
If a simulation consists of a single city then simulation obviously can be done in a reasonable amount of time. Simulation complexity exponentially grows with a num- ber of agents and for millions of agents in metric space a simulation often hits per- formance limitations. For example Moscow region in Russia contains more than 10 millions of people and simulation of this population is computationally expensive. 
232 M. Kondratyev and M. Garifullin 
Even more important problem is getting accurate prediction of the disease spreading on a country basis. With several highly populated regions modeling the whole country is an extremely expensive in terms of computation resources. Keeping results accurate prevents from scaling the country down or using techniques like grouping agents. Then distributed modeling can be applied to decrease the overall simulation time. Convert- ing the model into a distributed system is nontrivial task because there are communica- tions between people and movements of people between cities (figure 3). 
Fig. 3. Migration of agents 
In this example problem we represent movements between cities as periodic flights with a certain number of people onboard. There are no predefined schedules for flights, just randomly selected moments of time. 
This model was developed in AnyLogic in several versions. The first model was designed as a single threaded model and was used for later comparison. The model includes three cities. This baseline model can be further extended with additional agent behaviors like family contacts, employment and etc. In this case study we were analyzing spreading of a disease with one agent initially infected in a certain city. 
The model was distributed into three parts each containing a single city. Each part was executed in a separate thread. Planes were represented as messages with parame- ters, i.e. number of passengers onboard. For message passing we use RMI (a technol- ogy for rapid development of distributed systems integrated with Java 1.1). Submodels are synchronized using Time Warp algorithm [4]. 
Defining a remotely visible object starts from defining a special Java interface which should extend a predefined interface java.rmi.Remote. This interface defines methods which can be accessed remotely. Methods can be extended to receive pa- rameters – either of primitive types (integer, double, logical values etc.) or compound types. In case of using the compound types each type must be serializable. In this case Java creates a copy of such variable and sends the copy to the network. 
After defining the remote interface the interface should be implemented by a class. The class must extend java.rmi.server.UnicastRemoteObject. The last step is to create a skeleton and a stub using rmic compiler which is provided in Java Development Kit. Stubs and skeletons are used while making remote calls (figure 4). 
Parallel Discrete Event Simulation with AnyLogic 233 
Fig. 4. Java RMI technology in action. Stubs and skeletons are used while making remote calls. 
To send a message (plane with passengers) from a component 1 to a component 2 the component 1 obtains a remote reference to an object Airport_Imp. The reference is obtained using a special RMI naming service which resolves string names into references. The object Airport_Imp implements functions for message passing and can be considered as an intermediate level between the simulation model and RMI scope. Functions of the object Airport_Imp are defined in a remote interface Air- port_Int and therefore are available remotely. 
Instead of direct accessing the methods of Airport_Imp (e.g. accept a plain) the component 1 invokes methods of a stub Airport_Stub. The stub is a lightweight copy of Airport_Imp and is the only one class needed for the component 1 to be able to access Airport_Imp object. Implementation and the component 2 are located on a separate computer. 
RMI transmits the function call from the stub into a skeleton Airport_Skel over TCP/IP. The skeleton is created on the component 2 side. The skeleton receives parame- ters values and invokes the corresponding function of Airport_Imp. This invocation may pass a message to the model and the model may return data into the component 1. 
In the following section we present performance analysis for the model. Figure 5 shows a dependency of the overall wallclock time from a number of agents. Agents were uniformly distributed over all cities. The diagram contains two curves – one is for the single threaded model and another one is for the distributed version with three threads. The diagram shows 7-9 times better performance for the distributed version. One of the reasons of this performance improvement is a type of updates used in the single threaded model by the AnyLogic. When some agents interact with each other all other agents are refreshed. If a single agents gets sick then agents in all other cities were updated which never happens in a real life. 
234 M. Kondratyev and M. Garifullin 
Fig. 5. Dependence of wallclock time on the number of agents 
All these experiments were done on a Cure 2 Duo processor. Therefore one of the threads was executed on a single core and two others were sharing the second core. We expect even better results if using 3 independent computers or a processor with more than 2 cores. 
The model has proven the effect of converting the single threaded model into a dis- tributed model. The simulation time was decreased significantly using optimistic algorithm with rollbacks. In certain other simulation using purely optimistic algo- rithms potentially may give the same time as the single threaded model. Optimistic algorithms periodically save a system state including all agent states into a memory. In this particular model we were saving the system state each time a plane departs. Increasing a size of agents population will increase memory consumption and will definitely increase the time needed to save a state and later reload the state if a roll- back is needed. Using distributed approach gives performance improvements over single threaded models event in this case, but after a certain point optimistic algo- rithms should be replaced with conservative algorithms. 
Generally speaking, models with heavy computations and relatively small memory requirements can be efficiently synchronized with optimistic algorithms. Conservative algorithms are capable for simulation models with greater memory requirements and relatively simple event processing. 
Another factor influencing significant performance improvements in this model is tuning synchronization algorithms with additional information from the problem. E.g. we have considered average trip time between the cities. If a plane departs at time t, 
Parallel Discrete Event Simulation with AnyLogic 235 
then arriving of the plane is at time t + Δt. Considering Δt while saving states pre- vents algorithms from doing unnecessary rollbacks. Figure 6 shows a dependency of an overall simulation time from the value of Δt. The assumption of the model was that distance and therefore the travel time is the same for all three cities. Decrease in the simulation time is caused not only by increase in algorithms efficiency, but also be- cause of fewer events in the model. With the fixed number of planes the greater travel time decreases number of departures and arrivals in the same period of time. 
Fig. 6. Dependence of wallclock time on plane travel time 5 Conclusion 
The example model has proven the efficiency of converting a single threaded model into a distributed model. These results 
can be further improved, by using smarter algorithms with a relaxed synchronization. If a plane arrives to a city at 1:00 p.m. but the city time is 1:10 p.m. then causality problem occurs. If the time difference is neg- ligible then a model can skip a rollback and process the plane at 1:10 p.m. For this particular application this approach has an intuitive connection with a real life when a plane is delayed and arrives a bit later than scheduled. Ignoring the gap and process- ing the plane later allows avoiding spending CPU time on the rollback. 
For certain agent based models using optimistic algorithms and saving a model state only while sending messages can be less effective. E.g. there can be fairly small 
236 M. Kondratyev and M. Garifullin 
amount of messages between submodels and heavy calculation in between. If a roll- back occurs then a significant amount of calculation is lost. In this case the submodel can be extended with an ability to save its state periodically between sending mes- sages to other submodels. 
We plan to extend the model with ability to switch between synchronization algo- rithms. The basic version of the algorithms will be extended with additional smart elements, e.g. relaxed synchronization. So far we have implemented a part of the library blocks. Each block has a graphical interface and can be used for clear conver- sion of a single threaded AnyLogic model into a distributed AnyLogic model. The library allows selecting either optimistic or conservative algorithm. 
The library significantly increases performance not only when running a model on a network of computers, but also when running a model on multi core processors. 
